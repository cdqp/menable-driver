obj-m += menable.o

.PHONY: all clean mrproper install archive update reset _reset _copy_external_files


# SOURCE_DIR is always the path in which this Makefile is located,
# regardless from where make is called.
SOURCE_DIR := $(patsubst %/,%, $(dir $(abspath $(lastword $(MAKEFILE_LIST)))))
BUILD_DIR := /lib/modules/$(KERNELVER)/build

$(info CUSTOM_KERNEL_DIR=$(CUSTOM_KERNEL_DIR))

# If the user has specified a CUSTOM_KERNEL_DIR, then use it
ifneq ($(CUSTOM_KERNEL_DIR),)
    $(info Using custom kernel build directory $(CUSTOM_KERNEL_DIR))
    BUILD_DIR = $(CUSTOM_KERNEL_DIR)
else ifeq ($(KERNELVER),)
    # The new KERNELVER is given by the dkms config file
    BUILD_DIR = /lib/modules/$(shell uname -r)/build
endif

# Set $(src) manually when we're not in the KBuild process
# so the following search for sources always works.
ifeq ($(KERNELRELEASE),)
	src := $(SOURCE_DIR)
endif

# If no DRIVER_DIR was specified, define it to the parent directory,
# to allow to use this variable for copying external headers.
ifeq ($(DRIVER_DIR),)
	DRIVER_DIR := $(SOURCE_DIR)/..
endif

# If no RUNTIME_DIR was specified, define it to the parent directory,
# to allow to use this variable for copying external headers.
ifeq ($(RUNTIME_DIR),)
	RUNTIME_DIR := $(SOURCE_DIR)/../../Runtime
endif

# If no SHARED_DIR was specified, define it to the parent directory,
# to allow to use this variable for copying external headers.
ifeq ($(SHARED_DIR),)
	SHARED_DIR := $(SOURCE_DIR)/../../externals/Shared
endif

# Check if DRIVER_DIR was set via command line and store the information for later usage
IS_CLI_DRIVER_DIR := $(if $(findstring command line, $(origin DRIVER_DIR)),true,)

# the libpath must be relative to $(src) so that $(src) can be stripped
# from the paths later.
libroot := $(src)/..

INSTALL = /usr/bin/install
DEPMOD = /sbin/depmod

RHEL_MAJOR_VERSION = $(shell if [ -f /etc/redhat-release ]; then cat /etc/redhat-release | sed -r 's/.* release ([0-9]+).*/\1/'; else echo 0; fi)
ifeq ($(RHEL_MAJOR_VERSION),7)
	ccflags-y += -DRHEL7
endif

ccflags-y += -std=gnu99 -Wimplicit-fallthrough=3 -Wno-declaration-after-statement -Wno-unused-function -I"$(libroot)" -I"$(src)" -Wno-date-time

# debugging flags
# the -ftree-ter optimization is turned on explicitly to make the build work,
# all other optimizations can be turned off
ifdef DEBUG
	ccflags-y += -DDEBUG -ggdb -O0 -ftree-ter
else

  ifdef UNOPTIMIZED
	ccflags-y +=  -O0 -ftree-ter
  endif

  ifdef DBGSYM
	ccflags-y += -ggdb
  endif

endif

ifdef CFLAGS
ifeq "$(origin CFLAGS)" "command line"
	ccflags-y += $(CFLAGS)
endif
endif

# Search for sources and headers
DIRS := $(src)
DIRS += $(libroot)/lib/boards
DIRS += $(libroot)/lib/controllers
DIRS += $(libroot)/lib/dma
DIRS += $(libroot)/lib/fpga
DIRS += $(libroot)/lib/frontends
DIRS += $(libroot)/lib/helpers
DIRS += $(libroot)/lib/ioctl_interface
DIRS += $(libroot)/lib/os/
DIRS += $(libroot)/lib/os/linux
DIRS += $(libroot)/lib/os/linux/kernel
DIRS += $(libroot)/lib/pci
DIRS += $(libroot)/lib/uiq
SOURCES := $(foreach DIR, $(DIRS), $(wildcard $(DIR)/*.c))
HEADERS := $(foreach DIR, $(DIRS),  $(wildcard $(DIR)/*.h))

# KBuild expects file paths to be relative to the source directory.
SOURCES := $(SOURCES:$(src)/%=%)
HEADERS := $(HEADERS:$(src)/%=%)

# The autogenerated menable.mod.c is excluded from the sources.
SOURCES := $(filter-out menable.mod.c, $(SOURCES))

# Exclude some needless sources from build.
SOURCES := $(filter-out %/bpi_controller.c, $(SOURCES))

# Tell KBuild to build menable.o from the .o files 
# which will be generated from all the .c files
menable-y = $(SOURCES:.c=.o)

all: menable.ko

install: menable.ko udev/10-siso.rules udev/men_path_id udev/men_uiq udev/men_dma
	$(MAKE) -C $(BUILD_DIR) M=$(SOURCE_DIR) modules_install
	$(DEPMOD)
	$(INSTALL) udev/10-siso.rules /etc/udev/rules.d/
	$(INSTALL) udev/men_path_id udev/men_uiq udev/men_dma /sbin/

menable.ko: $(SOURCES) $(HEADERS) men_ioctl_codes.h sisoboards.h multichar.h
	$(MAKE) -C $(BUILD_DIR) M=$(SOURCE_DIR) modules

archive: men_ioctl_codes.h sisoboards.h multichar.h
	rm -f ../menable.tar.bz2
	tar cjf ../menable.tar.bz2 ../linux ../lib

# the wildcard extension is used to make the following targets depend on
# their source file only if it exists. This way the Makefile also works
# after copying the driver source tree to a location outside the repo.
men_ioctl_codes.h: $(wildcard $(DRIVER_DIR)/men_ioctl_codes.h)
	cp $(DRIVER_DIR)/men_ioctl_codes.h .

sisoboards.h: $(wildcard $(SHARED_DIR)/Common/SisoBoards/include/sisoboards.h)
	cp $(SHARED_DIR)/Common/SisoBoards/include/sisoboards.h .

multichar.h: $(wildcard $(RUNTIME_DIR)/Common/utils/include/multichar.h)
	cp $(RUNTIME_DIR)/Common/utils/include/multichar.h .

clean:
	$(MAKE) -C $(BUILD_DIR) M=$(SOURCE_DIR) clean
	rm -f *~ *.bak *.o *.o.*
	find $(libroot)/lib -name "*.o*" -delete
	find $(libroot)/lib -name "*.o.*" -delete

distclean: clean
	rm -f men_ioctl_codes.h sisoboards.h multichar.h
	rm -rf .cproject .gitignore .project .settings .vscode

# The update target raises an error if DRIVER_DIR was set within a Makefile,
# to prevent the user from updating from some random location
update: men_ioctl_codes.h sisoboards.h multichar.h
	$(if $(IS_CLI_DRIVER_DIR), $(info Updating from $(DRIVER_DIR)), $(error DRIVER_DIR must be set via command line to update))
	rsync -ruv $(DRIVER_DIR)/linux $(DRIVER_DIR)/lib ../

reset: _reset _copy_external_files

_reset:
	$(if $(IS_CLI_DRIVER_DIR), $(info Resetting from $(DRIVER_DIR)), $(error DRIVER_DIR must be set via command line to reset))
	rsync -rv --del $(DRIVER_DIR)/linux $(DRIVER_DIR)/lib ../

_copy_external_files: men_ioctl_codes.h sisoboards.h multichar.h

